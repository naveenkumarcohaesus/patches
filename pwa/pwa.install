<?php

/**
 * @file
 * PWA install hooks.
 */

use Drupal\Core\Url;
use Drupal\user\Entity\Role;
use Drupal\user\RoleInterface;

/**
 * Implements hook_requirements().
 */
function pwa_requirements($phase) {
  $requirements = [];

  if ($phase !== 'runtime') {
    return $requirements;
  }

  $t = 't';
  if ((isset($_SERVER['HTTPS']) && $_SERVER['HTTPS'] === 'on') || (isset($_SERVER["REQUEST_SCHEME"]) && $_SERVER["REQUEST_SCHEME"] === 'https')) {
    $requirements['pwa'] = [
      'title' => $t('Progressive Web App'),
      'value' => $t('HTTPS on'),
      'severity' => REQUIREMENT_OK,
      'description' => $t('Please make sure the certificate of %domain is valid for offline functionality to work.', ['%domain' => $_SERVER['HTTP_HOST']]),
    ];
  }
  elseif (in_array($_SERVER['HTTP_HOST'], ['localhost', '127.0.0.1'])) {
    $requirements['pwa'] = [
      'title' => $t('Progressive Web App'),
      'value' => 'localhost',
      'severity' => REQUIREMENT_WARNING,
      'description' => $t('You will need to configure HTTPS on your domain for this module to work.'),
    ];
  }
  else {
    $requirements['pwa'] = [
      'title' => $t('Progressive Web App'),
      'value' => $t('HTTPS off'),
      'severity' => REQUIREMENT_ERROR,
      'description' => $t('HTTPS need to be configured for the progressive web app module to work.'),
    ];
  }

  if (\Drupal::service('module_handler')->moduleExists('responsive_favicons')) {
    $tags = \Drupal::config('responsive_favicons.settings')->get('tags');
    $found = FALSE;
    foreach ($tags as $tag) {
      if (str_contains($tag, 'manifest') || str_contains($tag, 'theme-color')) {
        $found = TRUE;
        break;
      }
    }
    if ($found) {
      $requirements['pwa_responsive_favicons'] = [
        'title' => t('Progressive Web App (PWA) vs. Responsive Favicons Module conflict'),
        'value' => t('<strong>Conflicting "manifest" and / or "theme-color" tag entry found in your responsive favicons "tags" definition</strong>'),
        'severity' => REQUIREMENT_WARNING,
        'description' => t('Both the "Responsive Favicons" and "PWA" modules supply a "manifest" and "theme-color" header entry. Please remove the "manifest" and / or "theme-color" tags set on <a href="@responsive_favicons_admin_url">@responsive_favicons_admin_url</a>, so the ones generated by PWA can be used instead.', ['@responsive_favicons_admin_url' => Url::fromRoute('responsive_favicons.admin')->toString()]),
      ];
    }
  }

  if (!\Drupal::service('module_handler')->moduleExists('pwa_service_worker')) {
    $requirements['pwa_install_criteria'] = [
      'title' => t('Progressive Web App Install Criteria'),
      'value' => t('<strong>The PWA install criteria is not met for Firefox</strong>'),
      'severity' => REQUIREMENT_WARNING,
      'description' => t('As Firefox requires a <a href="@mdnLink">service worker "fetch" method</a> for the pwa install prompt to show up, you need to install the "pwa_service_worker" submodule to make your website installable through Firefox.<br><strong>Although Note</strong>, that this submodule has quite a few <a href="@issueLink">insufficiencies</a>.',
    [
      '@mdnLink' => 'https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps/Tutorials/js13kGames/Installable_PWAs#requirements',
      '@issueLink' => 'https://www.drupal.org/project/pwa/issues/3377120',
    ]),
    ];
  }

  return $requirements;
}

/**
 * Implements hook_install().
 */
function pwa_install() {
  // Set the site name dynamically.
  $site_name = \Drupal::config('system.site')->get('name');
  $output = [
    'name' => $site_name,
    'short_name' => substr($site_name, 0, 25),
  ];

  $config = \Drupal::configFactory()->getEditable('pwa.config');
  foreach ($output as $key => $value) {
    $config->set($key, $value);
  }
  $config->save();
}

/**
 * Implements hook_uninstall().
 */
function pwa_uninstall() {
  // Remove the pwa images:
  \Drupal::service('pwa.manifest')->deleteImages();
}

/**
 * Set the default offline_page variable.
 */
function pwa_update_8001(&$sandbox) {
  // Set the offline page path to the default value.
  $config_factory = \Drupal::configFactory();
  $config = $config_factory->getEditable('pwa.config');
  $config->set('offline_page', '/offline')->save(TRUE);
  // Remove the offline page path from the URL's to cache. It will be added
  // automatically in PWAController::pwa_serviceworker_file_data().
  $cache_urls = array_diff(pwa_str_to_list($config->get('urls_to_cache')), ['/offline']);
  $config->set('urls_to_cache', implode("\r\n", $cache_urls))->save(TRUE);
}

/**
 * Set default scope to "/".
 */
function pwa_update_8002() {
  $config_factory = \Drupal::configFactory();
  $config = $config_factory->getEditable('pwa.config');
  $config->set('scope', '/')
    ->save(TRUE);

  // Delete the cached config so that Drupal starts using the new config. Note
  // that invalidating this cache ID doesn't seem to do it for whatever reason,
  // so we have to actually delete it.
  \Drupal::cache('config')->delete('pwa.config');
}

/**
 * Remove the non-existent 'access pwa' permission from the anonymous user role.
 */
function pwa_update_8003() {
  user_role_revoke_permissions(RoleInterface::ANONYMOUS_ID, ['access pwa']);
}

/**
 * Add new orientation config and set originally hardcoded values in config.
 */
function pwa_update_9001() {
  $config = \Drupal::configFactory()->getEditable('pwa.config');
  // If these settings where empty before, they still got added to the
  // manifest.json through hard-coding. So we need to set them manually know:
  if (empty($config->get('background_color'))) {
    $config->set('background_color', '#ffffff');
  }
  if (empty($config->get('theme_color'))) {
    $config->set('theme_color', '#ffffff');
  }
  if (empty($config->get('display'))) {
    $config->set('display', '#ffffff');
  }
  // Add new 'orientation' config:
  $config
    ->set('orientation', 'portrait')
    ->save();
}

/**
 * Add new categories config.
 */
function pwa_update_9002() {
  $config = \Drupal::configFactory()->getEditable('pwa.config');

  // Add new 'categories' default:
  $config->set('categories', []);

  if (empty($config->get('start_url'))) {
    $config->set('start_url', '/');
  }
  if (empty($config->get('scope'))) {
    $config->set('scope', '/');
  }
  $config->save();
}

/**
 * Grant new permission.
 *
 * Grants new 'access pwa' permission to users with 'access content' permission,
 * which was used in PWA before.
 */
function pwa_update_9003() {
  $allRoles = Role::loadMultiple();
  foreach ($allRoles as $role) {
    if ($role->hasPermission('access content')) {
      $role
        ->grantPermission('access pwa')
        ->save();
    }
  }
}

/**
 * Rename "site_name" config to "name".
 */
function pwa_update_9004() {
  $config = \Drupal::configFactory()->getEditable('pwa.config');
  $oldSiteName = $config->get('site_name');
  $config
    ->set('name', $oldSiteName)
    ->clear('site_name')
    ->save();
}

/**
 * Remove the unused "lang" config key.
 */
function pwa_update_9005() {
  $config = \Drupal::configFactory()->getEditable('pwa.config');
  $config->set('dir', 'auto')
    ->save();
}

/**
 * Add new "manifest_path_mode" and "manifest_paths" configs.
 */
function pwa_update_9006() {
  $config = \Drupal::configFactory()->getEditable('pwa.config');
  $config->set('manifest_path_mode', 'all_except_listed')
    ->set('manifest_paths', "/admin\n/admin/*\n/batch\n/node/add*\n/node/*/*")
    ->save();
}

/**
 * Add and remove icon related configs.
 */
function pwa_update_9007() {
  $config = \Drupal::configFactory()->getEditable('pwa.config');
  $config->clear('default_image')->save();
}

/**
 * Create managed files for the already existing icons.
 *
 * IMPORTANT, if you have previously uploaded your icons in the private
 * directory (the location was based on your default file stream wrapper),
 * please temporarily set your default wrapper to 'public' and reupload the
 * pictures BEFORE continuing with this update!!
 */
function pwa_update_9008() {
  $config = \Drupal::configFactory()->getEditable('pwa.config');
  $imagePath = $config->get('image');
  $smallImagePath = $config->get('image_small');
  $verySmallImagePath = $config->get('image_very_small');

  $fileStorage = \Drupal::entityTypeManager()->getStorage('file');
  // There is already a managed file for the original 'image', but only its
  // path is stored in config, so we need to load it by uri and provide its
  // id instead:
  $images = $fileStorage->loadByProperties(['uri' => 'public://pwa/' . basename($imagePath)]);
  $image = reset($images) ?: NULL;

  if ($image !== NULL) {
    $fileUsage = \Drupal::service('file.usage');

    $image->setPermanent();
    $image->save();
    // We need to remove the old incorrect file usage here:
    $fileUsage->delete($image, 'PWA');

    // @todo Drupal core currently doesn't support linking images to config
    // entries nor routes, so we can not add a file usage here
    // (see https://www.drupal.org/project/pwa/issues/3389076):
    // $fileUsage->add($image, 'pwa', 'TODO', 'image');
    $config->set('image_fid', $image->id());
    $config->save();

    // Create the managed file for "image_small_fid":
    $imageSmall = $fileStorage->create([
      'filename' => basename($smallImagePath),
      'uri' => 'public://pwa/' . basename($smallImagePath),
      'status' => 1,
      'uid' => 1,
    ]);
    $imageSmall->setPermanent();
    $imageSmall->save();

    // @todo Drupal core currently doesn't support linking images to config
    // entries nor routes, so we can not add a file usage here
    // (see https://www.drupal.org/project/pwa/issues/3389076):
    // $fileUsage->add($imageSmall, 'pwa', 'TODO', 'image_small_fid');
    $config->set('image_small_fid', $imageSmall->id());
    $config->save();

    // Create the managed file for "image_very_small_fid":
    $imageVerySmall = $fileStorage->create([
      'filename' => basename($verySmallImagePath),
      'uri' => 'public://pwa/' . basename($verySmallImagePath),
      'status' => 1,
      'uid' => 1,
    ]);
    $imageVerySmall->setPermanent();
    $imageVerySmall->save();

    // @todo Drupal core currently doesn't support linking images to config
    // entries nor routes, so we can not add a file usage here
    // (see https://www.drupal.org/project/pwa/issues/3389076):
    // $fileUsage->add($imageVerySmall, 'pwa', 'TODO', 'image_very_small_fid');
    $config->set('image_very_small_fid', $imageVerySmall->id());
    $config->save();
  }
  else {
    // If the 'image' config is empty, we should make sure all configs are
    // empty and let the user reupload those manually:
    $config->set('image_fid', NULL)
      ->set('image_small_fid', NULL)
      ->set('image_very_small_fid', NULL);
  }
  $config
    ->clear('image')
    ->clear('image_small')
    ->clear('image_very_small')
    ->save();
}

/**
 * Install the new "pwa_service_worker" submodule and move the related configs.
 */
function pwa_update_9009() {
  // Install the new submodule:
  \Drupal::service('module_installer')->install(['pwa_service_worker']);

  $pwaConfig = \Drupal::configFactory()->getEditable('pwa.config');
  $swConfig = \Drupal::configFactory()->getEditable('pwa_service_worker.config');
  // Map old configs:
  $swConfig->set('urls_to_cache', $pwaConfig->get('urls_to_cache'))
    ->set('urls_to_exclude', $pwaConfig->get('urls_to_exclude'))
    ->set('offline_page', $pwaConfig->get('offline_page'))
    ->set('cache_version', 1)
    ->set('skip_waiting', $pwaConfig->get('skip_waiting'))
    ->save();
  // Clear old configs:
  $pwaConfig->clear('urls_to_cache')
    ->clear('urls_to_exclude')
    ->clear('offline_page')
    ->clear('cache_version')
    ->clear('skip_waiting')
    ->save();
  // There are several caches which need to be cleared for the update, so
  // we just clear all of them:
  drupal_flush_all_caches();
}
